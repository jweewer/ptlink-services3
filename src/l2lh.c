/**********************************************************************
 * PTlink IRC Services is (C) CopyRight PTlink IRC Software 1999-2005 *
 *                     http://software.pt-link.net                    *
 * This program is distributed under GNU Public License               *
 * Please read the file COPYING for copyright information.            *
 **********************************************************************
                                                                                
  Description: .lh file generation tool
                                                                                
 *  $Id: l2lh.c,v 1.4 2005/09/22 16:35:44 jpinto Exp $
*/
#include "stdinc.h"
#include "ircservice.h"
#include "lang.h"
#include "ircsvs.h"
#include "strhand.h"

#define MAX_ITEMS	256	/* maximum items on one lang file */
char* lang_items[MAX_ITEMS];
char lang_table[MAX_ITEMS][MAX_LANGS][1024];
static int missing_str[MAX_LANGS];
char* item = NULL;
int itcount = 0;

int find_item(char *name);
int item_posicion(char *name);

/* map \b,\u to the IRC control chars */
static void map2controls(char* line)
{
  char tmp[512];
  char *p = line;
  int i = 0;
  
  while(*p)
    {
      if(*p == '\\')
        {
          if(p[1]=='b' || p[1]=='B') /* bold */
            {
                tmp[i++] = 2;
                p += 2;
                continue;
            }
          if(p[1]=='u' || p[1]=='U') /* underline */
            {
                tmp[i++] = 31;
                p += 2;
                continue;
            }
          if(p[1]=='c' || p[1]=='C') /* color, TBD */
            {
                tmp[i++] = 3;
                p += 2;
                continue;
            }            
        }
      tmp[i++]=*p;      
        ++p;
    }
  tmp[i] = 0;
  strncpy(line, tmp, 512);
}

/* returns a string with format letters */
static char* format(char* str)
{
  static char tmp[64];
  char *p;
  int i = 0;

  p = str;
  while(*p)
    {
      if(*p=='%')
        {
          if(p[1]=='%')
            ++p;
          else
            tmp[i++] = p[1];
        }
      ++p;
    }
  tmp[i]='\0';
  return tmp;
}
/* find an item on the array, if not found add it */
int item_posicion(char *name)
{
  int i = 0;
  while(i<itcount && (strcasecmp(name, lang_items[i])!=0))
    ++i;
  if(i<itcount) /* item was found */
    return i;
  /* we need to add this new item */
  lang_items[i]=strdup(name);
  ++itcount;
  return i;
}

/* find an item on the array */
int find_item(char *name)
{
  int i = 0;
  while(i<itcount && (strcasecmp(name, lang_items[i])!=0))
    ++i;
    
  if(i<itcount) /* item was found */
    return i;
    
  return -1;
}

#define ABORT_PROG \
    fclose(fin);\
    fclose(fout);\
    unlink(outfn);\
    exit(-1);
    
int main(int argc, char* argv[])
{
  FILE *fin, *fout;
  char outfn[256];
  char line[512];
  char *lim1, *lim2;  
  int current_item = 0;
  int current_lang = 0;
  char *c;
  int i, nl;
  char *default_format;
  int linenum = 0;
  
  if(argc!=2)
    {
      printf("Usage: %s file.l\n", argv[0]);
      return -1;
    }
  fin = fopen(argv[1],"rt");
  if(IsNull(fin))
    {
      printf("Could not open %s.\n", argv[1]);
      return -2;
    }
  snprintf(outfn, sizeof(outfn),"%sh",argv[1]);
  fout = fopen(outfn, "w+");
  if(IsNull(fout))
    {
      printf("Could not create %s.\n", outfn);
      return -2;
    } 
  printf("Compiling language file %s\n", argv[1]);
  fprintf(fout, "/* File automatically generated by l2lh\n"
  		" Do not edit this file manually */\n");
  /* start processing the file */
  while(fgets(line,sizeof(line), fin))
    {
      ++linenum;
      if(line[0]=='+') /* its an item mark  */
        {         
          if(line[1]=='+')  /* its a comment, skip it */
            continue;
          lim1 = strchr(&line[1],'(');
          if(IsNull(lim1))
	    {
	       fprintf(stderr,"Missing \"(\" on language item at line %d\n", linenum);
	       ABORT_PROG
	       return -3;
            }
          lim2 = strchr(lim1+1,')');
          if(IsNull(lim2))
	    {
	      fprintf(stderr,"Missing \")\" on language item at line %d\n", linenum);
	      ABORT_PROG
	      return -3;
            }
          (*lim1) = '\0'; ++lim1;
          (*lim2) = '\0';
          if(item) /* close previous item */
            free(item);
          current_item = item_posicion(&line[1]);
          lang2index(lim1, current_lang);  
          if(current_lang == -1)
	    {
	      fprintf(stderr,"Aborting: Unknown language id %s at line %d\n", lim1, linenum);
	      ABORT_PROG
            }
          lang_table[current_item][current_lang][0]='\0';
        }
      else  /* its one item line */
        {
          c = strchr(line,'\n');
          if(c)
            *c='\0';
          c = strchr(line,'\r');
          map2controls(line);
          if(c)
            *c='\0';
          if(line[0]=='@')
          {
            int ipos = find_item(&line[1]);                        
            if(ipos == -1)
            {
              fprintf(stderr,"Unknown reference %s at line %d !\n", line, linenum);
              ABORT_PROG
            }
            else 
            if(ipos == current_item)
            {
              fprintf(stderr,"Invalid self reference %s at line %d !\n", line, linenum);	   
              ABORT_PROG            
            }
            else
            {
              int p;
              strcat(lang_table[current_item][current_lang], lang_table[ipos][current_lang]);
              p = strlen(lang_table[current_item][current_lang]);
              /* we need to remove the trailing "\n" */
              lang_table[current_item][current_lang][p-2] = '\0';
            }
          }
          else if(line[0]=='\0')
            strcat(lang_table[current_item][current_lang], " ");
          else
            strcat(lang_table[current_item][current_lang], line);
          strcat(lang_table[current_item][current_lang], "\\n");
        }
    }
   
  /* Items are now in memory, we are going to create the .lh file*/
  i = 0;  
  while(i<itcount)
    {
      fprintf(fout,"const char* %s[%i] = {\n", lang_items[i], MAX_LANGS);
      if(lang_table[i][0] == NULL || lang_table[i][0][0]=='\0')
        {
          fprintf(stderr,"Missing default lang item for %s\n", 
            lang_items[i]);
          ABORT_PROG
          return 2;
        }
      default_format = strdup(format(lang_table[i][0]));
      for(nl=0; nl < MAX_LANGS; ++nl)
        {
          if(lang_table[i][nl]!=NULL && lang_table[i][nl][0]!='\0')
            {
              if(nl > 0) /* let's validate the format strings */
                {
                  char *l;
                  index2lang(nl, l);
                  /* we dont't check on DATE_FORMATs */
                  if((strstr(lang_items[i], "DATE_FORMAT") == NULL) 
                    && strcmp(default_format, format(lang_table[i][nl])))
                    {
                      fprintf(stderr,"Format string is not correct on %s(%s)\n", 
                        lang_items[i], l);
                        ABORT_PROG
                    }
                }              
              fprintf(fout,"\"%s\"", lang_table[i][nl]);
            }
          else
            {
              fprintf(fout,"\"%s\"", lang_table[i][0]);
              missing_str[nl]++;
            }
          if(nl < MAX_LANGS-1)
            fprintf(fout,",\n");
        }
      free(default_format);
      fprintf(fout,"\n};\n\n");
      ++i;
  }
  fclose(fin);
  fclose(fout);
  /* Lets display some stats */
  printf("Results: ");
  for(nl=0; nl < MAX_LANGS; ++nl)
    {
      char *l;
      index2lang(nl, l);
      if(nl>0)
        printf("; ");
      printf("%s (%3.0f%%)", l, ((itcount- missing_str[nl]) / (float)itcount) * 100);
    }
  printf("\n");
  return 0;
}
